/**************************************************************************************************
 MG_CANAL_LEVEL.C

 Канальный уровень MilliGanjubus
 
 Формат обрабатываемых пакетов:
 
   |<-------------------------- Joint ---------------------------->|       
   |                         |<----------- Stuff ---------->|      |
   -----------------------------------------------------------------
   | BB | Addr | Size | CRC8 | ... ... ... data ... ... ... | CRC8 |
   -----------------------------------------------------------------
     0     1      2      3      4

**************************************************************************************************/


#include <mg_canal_level.h>



/**************************************************************************************************
                                    ПРОТОТИПЫ ЛОКАЛЬНЫХ ФУНКЦИЙ
**************************************************************************************************/

static void processStartByte(uint8_t dataByte, mg_input * msg);
static void processDevAddress(uint8_t dataByte, mg_input * msg);
static void processSize(uint8_t dataByte, mg_input * msg);
static void processHeaderCrc(uint8_t dataByte, mg_input * msg);
static done_inprogress processStuffAndCrc(uint8_t dataByte, mg_input * msg);
static bool isDevAddrValid(uint8_t dataByte, mg_input * msg);
static bool isSizeValid(uint8_t dataByte);



/**************************************************************************************************
                                        ГЛОБАЛЬНЫЕ ФУНКЦИИ
**************************************************************************************************/

/**************************************************************************************************
Описание:  Реализация конечного автомата сборки принятого сообщения
Аргументы: Байт данных для обработки, указатель на структуру, содержащую обрабатываемое сообщение
Возврат:   DONE / IN_PROGRESS
Замечания:
**************************************************************************************************/
done_inprogress MG_ComposeMsg(uint8_t dataByte, mg_input * msg)
{
	if (CheckSoftTimer(&msg->timer))
	{
		msg->counter = 0;
	}
	StartSoftTimer(&msg->timer, MG_MAX_RECEIVE_DELAY);
	
	switch (msg->counter)
	{
		//-----------------------------------------------------------
		case MG_OFFSET_START_BYTE:
			{
				processStartByte(dataByte, msg);
				break;
			}
		//-----------------------------------------------------------
		case MG_OFFSET_DEV_ADR:
			{
				processDevAddress(dataByte, msg);
				break;
			}
		//-----------------------------------------------------------			
		case MG_OFFSET_SIZE:
			{
				processSize(dataByte, msg);
				break;
			}
		//-----------------------------------------------------------	
		case MG_OFFSET_HEADER_CRC:
			{
				processHeaderCrc(dataByte, msg);
				break;
			}
		//-----------------------------------------------------------	
		default:
			{
				return (processStuffAndCrc(dataByte, msg));
			}
 	}
	
	return RET_IN_PROGRESS;
}



/**************************************************************************************************
Описание:  Осуществляет подготовку исходящего сообщения
Аргументы: Указатель на структуру, содержащую сообщение
Возврат:   Нет
Замечания:
**************************************************************************************************/
void MG_WrapMsg(mg_output * msg)
{
	msg->jointSize = msg->stuffSize + MG_HEADER_SIZE + MG_CRC_SIZE;
	
	msg->joint[MG_OFFSET_START_BYTE] = MG_START_BYTE;
	msg->joint[MG_OFFSET_DEV_ADR] = msg->devAdr;
	msg->joint[MG_OFFSET_SIZE] = msg->jointSize;
	msg->joint[MG_OFFSET_HEADER_CRC] = Crc8(msg->joint, MG_HEADER_SIZE - 1);
	msg->joint[msg->jointSize - 1] = Crc8(msg->joint, msg->jointSize - 1);
}



/**************************************************************************************************
Описание:  Возвращает необходимость ответа на обрабатываемый запрос
Аргументы: Указатель на структуру, содержащую обрабатываемый запрос
Возврат:   True, если запрос нуждается в ответе, false - ответ не нужен
Замечания:
**************************************************************************************************/
bool MG_IsAnsNeeded(mg_input * msg)
{
	if (msg->joint[MG_OFFSET_DEV_ADR] == G_BROADCAST_DEV_ADDRESS)
	{
		return false;
	}
	else
	{
		return true;
	}
}



/**************************************************************************************************
                                       ЛОКАЛЬНЫЕ ФУНКЦИИ
**************************************************************************************************/

/**************************************************************************************************
Описание:  Обработка принятого байта: ожидание первого стартового байта
Аргументы: Байт данных, указатель на структуру, содержащую обрабатываемый запрос
Возврат:   Нет
Замечания:
**************************************************************************************************/
static void processStartByte(uint8_t dataByte, mg_input * msg)
{
	if (MG_START_BYTE == dataByte)
	{
		msg->joint[msg->counter] = dataByte;
		msg->counter++;
	}	
}



/**************************************************************************************************
Описание:  Обработка принятого байта: ожидание адреса устройства
Аргументы: Байт данных, указатель на структуру, содержащую обрабатываемый запрос
Возврат:   Нет
Замечания:
**************************************************************************************************/
static void processDevAddress(uint8_t dataByte, mg_input * msg)
{
	if (isDevAddrValid(dataByte, msg) == true)
	{
		msg->joint[msg->counter] = dataByte;
		msg->counter++;
	}
	else
	{
		msg->counter = 0;
		processStartByte(dataByte, msg);
	}	
}



/**************************************************************************************************
Описание:  Обработка принятого байта: ожидание размера передаваемого пакета
Аргументы: Байт данных, указатель на структуру, содержащую обрабатываемый запрос
Возврат:   Нет
Замечания:
**************************************************************************************************/
static void processSize(uint8_t dataByte, mg_input * msg)
{
	if (isSizeValid(dataByte) == true)
	{
		msg->jointSize = dataByte;
		msg->joint[msg->counter] = dataByte;
		msg->counter++;
	}
	else
	{
		msg->counter = 0;
		processStartByte(dataByte, msg);
	}
}



/**************************************************************************************************
Описание:  Обработка принятого байта: ожидание корректной контрольной суммы заголовка
Аргументы: Байт данных, указатель на структуру, содержащую обрабатываемый запрос
Возврат:   Нет
Замечания:
**************************************************************************************************/
static void processHeaderCrc(uint8_t dataByte, mg_input * msg)
{
	if (Crc8(msg->joint, MG_HEADER_SIZE - 1) == dataByte)
	{
		msg->joint[msg->counter] = dataByte;
		msg->counter++;
	}
	else
	{
		msg->counter = 0;
		processStartByte(dataByte, msg);
	}
}



/**************************************************************************************************
Описание:  Обработка принятого байта: сохранение тела запроса, проверка контрольной суммы в конце приема
Аргументы: Байт данных, указатель на структуру, содержащую обрабатываемый запрос
Возврат:   Нет
Замечания:
**************************************************************************************************/
static done_inprogress processStuffAndCrc(uint8_t dataByte, mg_input * msg)
{
	msg->joint[msg->counter] = dataByte;
	msg->counter++;

	if (msg->counter >= msg->jointSize)
	{
		msg->counter = 0;
		
		uint8_t receivedCrc = msg->joint[msg->jointSize - 1];	
		uint8_t calculatedCrc = Crc8(msg->joint, msg->jointSize - 1);
		if (receivedCrc == calculatedCrc)
		{
			msg->stuff = &msg->joint[MG_OFFSET_STUFF];
			msg->stuffSize = msg->jointSize - MG_HEADER_SIZE - MG_CRC_SIZE;
			return RET_DONE;
		}
	}
	return RET_IN_PROGRESS;
}



/**************************************************************************************************
Описание:  Проверка принятого адреса
Аргументы: Байт данных
Возврат:   True, если адрес допустим
Замечания:
**************************************************************************************************/
static bool isDevAddrValid(uint8_t dataByte, mg_input * msg)
{
	return ((dataByte == msg->devAdr) ||
            (dataByte == G_BROADCAST_DEV_ADDRESS) ||
			(dataByte == G_DIRECT_DEV_ADDRESS));
}



/**************************************************************************************************
Описание:  Проверка принятого размера запроса
Аргументы: Байт данных
Возврат:   True, если размер допустим
Замечания:
**************************************************************************************************/
static bool isSizeValid(uint8_t dataByte)
{
	return 	((dataByte >= MG_MIN_REQ_SIZE) && (dataByte <= MG_MAX_REQ_SIZE));
}
